1. 
*JUnit предлагает инициализацию и очистку на двух уровнях, до и после каждого метода и класса. ** У нас есть @ BeforeEach , @ AfterEach на уровне метода и @ BeforeAll и @ AfterAll на уровне класса.

*TestNG также обеспечивает инициализацию и очистку на уровне метода и класса . В то время как @ BeforeClass и @ AfterClass остаются неизменными на уровне класса, аннотации на уровне метода представляют собой @ BeforeMethod и @ AfterMethod. TestNG также предлагает аннотации @ BeforeSuite, @AfterSuite, @BeforeGroup и @AfterGroup для конфигураций на уровне комплектов и групп. Кроме того, мы можем использовать @ BeforeTest и @ AfterTest , если нам потребуется какая-либо конфигурация до или после тестовых случаев, включенных в тег <test> в ​​XML-файле конфигурации TestNG. Объявление методов @ BeforeClass и @ AfterClass должно быть статическим в JUnit. Для сравнения, объявление метода TestNG не имеет этих ограничений.

2.
*Обе платформы поддерживают игнорирование тестовых случаев ** , хотя они делают это совершенно по-разному. JUnit предлагает аннотацию @ Ignore

*TestNG использует @ Test с параметром «enabled» с логическим значением true или false

3.
*Мы можем использовать аннотации @ RunWith, @ SelectPackages и @ SelectClasses для группировки тестовых случаев и запускать их как набор в JUnit 5 . ** Набор представляет собой набор тестовых случаев, которые мы можем сгруппировать и запустить как одиночный тест.

Если мы хотим сгруппировать тестовые примеры разных пакетов для совместной работы в _Suite , нам нужна аннотация @ SelectPackages_. Если мы хотим, чтобы определенные тестовые классы работали вместе, JUnit 5 обеспечивает гибкость благодаря @ SelectClasses.

*В TestNG мы можем группировать тесты, используя файл XML. Это означает, что RegistrationTest и SignInTest будут работать вместе.

Помимо группировки классов, TestNG также может группировать методы, используя аннотацию @ Test (groups = ”groupName”) 

4.
*В JUnit 5 мы можем использовать __assertThrows __API для проверки исключений.

*с TestNG мы также можем реализовать то же самое. Эта функция подразумевает, какое исключение выдается из фрагмента кода, который является частью теста.

5.
*В JUnit 5 у нас есть преимущество в том, что методы тестирования используют аргументы данных непосредственно из сконфигурированного источника. ** По умолчанию JUnit 5 предоставляет несколько source аннотаций, таких как:
@ ValueSource: мы можем использовать это с массивом значений типа
Short, Byte, Int, Long, Float, Double, Char, и String
__ @ EnumSource - passes Enum __constants как параметры теста
__ @ MethodSource - p __asses внешние методы, генерирующие потоки
@ CsvSource – использует значения CSV в качестве источника для параметров

*В TestNG мы можем параметризовать тесты, используя аннотации @ Parameter или @ DataProvider . ** При использовании файла XML аннотируйте метод теста с помощью @ Parameter и предоставить данные в файле XML. Хотя использование информации в файле XML просто и полезно, в некоторых случаях вам может потребоваться предоставить более сложные данные.
Для этого мы можем использовать аннотацию @ DataProvider , которая позволяет нам отображать сложные типы параметров для методов тестирования.

6.
В JUnit 4 и TestNG мы можем провести один и тот же тест, используя @ Test (timeout = 1000)

7. TestNG поддерживает тестирование зависимостей. Это означает, что в наборе методов тестирования, если первоначальный тест не пройден, все последующие зависимые тесты будут пропущены, а не помечены как неудачные, как в случае с JUnit.

8. 
*Не существует определенного неявного порядка, в котором тестовые методы будут выполняться в JUnit 4 или TestNG. ** Методы просто вызываются, как возвращено Java Reflection API. Начиная с JUnit 4 он использует более детерминированный, но не предсказуемый порядок.
Чтобы получить больше контроля, мы аннотируем тестовый класс с аннотацией @ FixMethodOrder и упомянем сортировщик методов. Параметр MethodSorters.NAME ASCENDING сортирует методы по имени метода в лексикографическом порядке. Помимо этого сортировщика у нас есть также MetTestNG также предоставляет несколько способов контроля в порядке выполнения метода тестирования. Мы предоставляем параметр priority в аннотации @ TesthodSorter.DEFAULT и MethodSorter.JVM.__

*TestNG также предоставляет несколько способов контроля в порядке выполнения метода тестирования. Мы предоставляем параметр priority в аннотации @ Test. Обратите внимание, что приоритет вызывает методы тестирования, основанные на приоритете, но не гарантирует, что тесты на одном уровне завершены до вызова следующего уровня приоритета.

9. *По умолчанию всякий раз, когда мы запускаем тест, класс теста и имя метода теста печатаются в консоли или IDE. JUnit 5 предоставляет уникальную возможность, где мы можем упоминать пользовательские описательные имена для классов и методов тестирования, используя аннотацию @ DisplayName .

*Прямо сейчас в TestNG нет способа предоставить собственное имя.

10. JUnit и TestNG, несомненно, являются двумя наиболее популярными средами модульного тестирования в экосистеме Java. Хотя JUnit вдохновляет сам TestNG, он предоставляет свои отличительные особенности и, в отличие от JUnit, работает для функционального и более высокого уровней тестирования.